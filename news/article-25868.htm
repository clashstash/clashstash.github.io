<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://clashstash.github.io/news/article-25868.htm" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Spring注解开发_Spring容器创建概述_在线工具</title>
        <meta name="description" content="浅尝Spring注解开发，基于Spring 4.3.12概述Spring容器创建的过程，包括12个方法的执行  浅尝Spring注解开发_自定义注册组件、属性赋值、自动装配浅尝Spring注解开发_B" />
        <link rel="icon" href="/assets/website/img/clashstash/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="ClashStash官方节点站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://clashstash.github.io/news/article-25868.htm" />
    <meta property="og:site_name" content="ClashStash官方节点站" />
    <meta property="og:title" content="Spring注解开发_Spring容器创建概述_在线工具" />
    <meta property="og:image" content="https://clashstash.github.io/uploads/20240709/702df6f9648a09672869954df62e6f5b.webp" />
        <meta property="og:release_date" content="2024-12-14T10:13:05" />
    <meta property="og:updated_time" content="2024-12-14T10:13:05" />
        <meta property="og:description" content="浅尝Spring注解开发，基于Spring 4.3.12概述Spring容器创建的过程，包括12个方法的执行  浅尝Spring注解开发_自定义注册组件、属性赋值、自动装配浅尝Spring注解开发_B" />
        
    <link rel="stylesheet" href="/assets/website/css/clashstash/maicons.css">
    <link rel="stylesheet" href="/assets/website/css/clashstash/bootstrap.css">
    <link rel="stylesheet" href="/assets/website/css/clashstash/theme.css">

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Spring注解开发_Spring容器创建概述_在线工具">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FGG26WJLQX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FGG26WJLQX');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
    <!-- Back to top button -->
    <div class="back-to-top"></div>
    <header>
                <nav class="navbar navbar-expand-lg navbar-light bg-white sticky" data-offset="500">
            <div class="container">
                                <a href="/" class="navbar-brand">Clash<span class="text-primary">Stash</span></a>
                                <button class="navbar-toggler" data-toggle="collapse" data-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="navbar-collapse collapse" id="navbarContent">
                    <ul class="navbar-nav ml-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/free-nodes/">免费节点</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/paid-subscribe/">推荐机场</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/news/">新闻资讯</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="#">关于</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">联系</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <div class="container">
            <div class="page-banner">
                <div class="row justify-content-center align-items-center h-100">
                    <div class="col-md-6">
                        <nav aria-label="Breadcrumb">
                            <ul class="breadcrumb justify-content-center py-0 bg-transparent">
                                <li class="breadcrumb-item"><a href="/">首页</a></li>
                                <li class="breadcrumb-item"><a href="/news/">新闻资讯</a></li>
                                <li class="breadcrumb-item active">正文</li>
                            </ul>
                        </nav>
                        <h1 class="text-center">Spring注解开发_Spring容器创建概述_在线工具</h1>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <div class="page-section" id="about">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				</h1> <blockquote> <p>浅尝Spring注解开发，基于Spring 4.3.12<br /><font color="red">概述Spring容器创建的过程，包括12个方法的执行</font></p> </blockquote> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/wei-ran/p/16203112.html"  title="浅尝Spring注解开发_自定义注册组件、属性赋值、自动装配" target="_blank"  rel="nofollow">浅尝Spring注解开发_自定义注册组件、属性赋值、自动装配</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/wei-ran/p/16207148.html"  title="浅尝Spring注解开发_Bean生命周期及执行过程" target="_blank"  rel="nofollow">浅尝Spring注解开发_Bean生命周期及执行过程</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/wei-ran/p/16213120.html"  title="浅尝Spring注解开发_AOP原理及完整过程分析（源码）" target="_blank"  rel="nofollow">浅尝Spring注解开发_AOP原理及完整过程分析（源码）</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/wei-ran/p/16221178.html"  title="浅尝Spring注解开发_声明式事务及原理" target="_blank"  rel="nofollow">浅尝Spring注解开发_声明式事务及原理</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/wei-ran/p/16221760.html"  title="浅尝Spring注解开发_简单理解BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor、ApplicationListener" target="_blank"  rel="nofollow">浅尝Spring注解开发_简单理解BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor、ApplicationListener</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/wei-ran/p/16222835.html"  title="Spring注解开发_Spring容器创建概述" target="_blank"  rel="nofollow">Spring注解开发_Spring容器创建概述</a></p> <h2 id="概述12个方法">概述12个方法</h2> <pre><code class="language-java">	//获取ioc容器 	AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfPropertyValues.class); </code></pre> <pre><code class="language-java">	/** 	 * 创建一个新的AnnotationConfigApplicationContext，派生bean定义 	 * 从给定的带注释的类，并自动刷新上下文。 	 * @param 类一个或多个带注释的类 	 * e.g. {@link Configuration @Configuration} classes 	 */ 	public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) { 		this(); 		register(annotatedClasses); 		refresh(); 	} </code></pre> <pre><code class="language-java">	@Override 	public void refresh() throws BeansException, IllegalStateException { 		synchronized (this.startupShutdownMonitor) { 			// 为刷新准备此上下文。 			prepareRefresh();  			// 告诉子类刷新内部bean工厂。 			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  			// 准备在此上下文中使用bean工厂。 			prepareBeanFactory(beanFactory);  			try { 				// 允许在上下文子类中对bean工厂进行后处理。 				postProcessBeanFactory(beanFactory);  				// 调用在上下文中注册为bean的工厂处理器。 				invokeBeanFactoryPostProcessors(beanFactory);  				// 注册拦截bean创建的bean处理器。 				registerBeanPostProcessors(beanFactory);  				// 初始化此上下文的消息源。 				initMessageSource();  				// 为此上下文初始化事件多播。 				initApplicationEventMulticaster();  				// 在特定的上下文子类中初始化其他特殊bean。 				onRefresh();  				// 检查监听器bean并注册它们。 				registerListeners();  				// 实例化所有剩余的(非lazy-init)单例。 				finishBeanFactoryInitialization(beanFactory);  				// 最后一步:发布相应的事件。 				finishRefresh(); 			}         	//... </code></pre> <h2 id="beanfactory预处理">BeanFactory预处理</h2> <blockquote> <p>BeanFactory的创建及预准备工作</p> <ul> <li>BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义</li> <li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</li> <li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</li> <li>所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合</li> </ul> </blockquote> <p>1、<code>this()</code></p> <ol> <li>先调用父类构造器</li> <li>声明两个类，通过读取注解或者扫描类路径读取<code>BeanDefinition</code> </li> <li>初始化了<font color="red"><strong>DefaultListableBeanFactory</strong></font>：基于bean定义元数据的成熟bean工厂，可通过后处理器进行扩展，内部定义了 <code>BeanDefinition</code>的<code>Map</code>属性名<code>beanDefinitionMap</code>，可以操作<code>bean</code> </li> <li>注册了多个（6个）默认的后置处理器</li> </ol> <p>2、<code>register(annotatedClasses)</code></p> <ol> <li>校验传入的 <code>JavaConfig.class</code>配置类的注解（是否需要忽略）</li> <li>处理通用注解</li> <li>封装为<code>BeanDefinitionHolder</code>后，注册到容器中</li> <li>相当于将JavaConfig配置类作为一个Bean注册到容器中</li> </ol> <p>3、Spring容器的<code>refresh()</code>：创建刷新</p> <ol> <li> <code>prepareRefresh()</code>：刷新前的预处理</p> <ol> <li> <code>initPropertySources()[初始化属性源]</code>：初始化一些属性设置，空方法，留给子类自定义个性化的属性设置方法</li> <li> <code>getEnvironment().validateRequiredProperties()</code>：检验属性的合法等</li> <li> <code>earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;()</code>：保存容器中的一些早期的事件，一旦多播机可用就会发布</li> </ol> </li> <li> <code>obtainFreshBeanFactory()(//告诉子类刷新内部Bean工厂)</code>：获取新鲜的<code>BeanFactory</code></p> <ol> <li> <code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</code>类注释：<code>//大多数可列出的bean工厂要实现的配置接口。 除了 {@link ConfigurableBeanFactory} 之外，它还提供了以下工具： 分析和修改 bean 定义，并预实例化单例。</code> </li> <li> <code>refreshBeanFactory()</code>：刷新<s>[创建]</s><code>BeanFactory</code></p> <ol> <li>创建了一个<code>this.beanFactory = new DefaultListableBeanFactory()</code>。<font color="red">补充：这个方法在创建<code>AnnotationConfigApplicationContext</code>的父类<code>GenericApplicationContext</code>的无参构造时调用了，注释是<code>//创建一个新的 GenericApplicationContext</code></font> </li> <li>设置id</li> </ol> </li> <li> <code>getBeanFactory()</code>：返回刚才<code>GenericApplicationContext</code>创建的<code>BeanFactory</code>对象</li> <li>将创建的<code>BeanFactory</code>[类型：<code>DefaultListableBeanFactory</code>]返回</li> </ol> </li> <li> <code>prepareBeanFactory(beanFactory)</code>：<code>BeanFactory</code>的预准备工作（<code>BeanFactory</code>进行一些设置）</p> <ol> <li>设置<code>BeanFactory</code>的类加载器、支持表达式解析器...</li> <li>添加部分<code>BeanPostProcessor</code>[类型：<code>ApplicationContextAwareProcessor</code>]</li> <li>设置忽略的自动装配的接口<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>xxx...</code> </li> <li>注册可以解析的自动装配；我们能直接在任何组件中自动注入：<code>BeanFactory</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code>、<code>ApplicationContext...</code> </li> <li>添加<code>BeanPostProcessor</code>[类型：<code>ApplicationListenerDetector</code>]，将用于检测内部 bean 的早期后处理器注册为 <code>ApplicationListener</code> </li> <li>添加编译时的<code>AspectJ</code> </li> <li>给<code>BeanFactory</code>中注册一些能用的组件； <ol> <li> <code>ConfigurableEnvironment environment</code>： <code>application</code>上下文环境</li> <li> <code>Map&lt;String, Object&gt; systemProperties</code>：系统属性</li> <li> <code>Map&lt;String, Object&gt; systemEnvironment</code>：系统环境变量</li> </ol> </li> </ol> </li> <li> <code>postProcessBeanFactory(beanFactory)</code>：<code>BeanFactory</code>准备工作完成后进行的后置处理工作</p> <ol> <li>子类通过重写这个方法来在<code>BeanFactory</code>创建并预准备完成以后做进一步的设置</li> </ol> </li> </ol> <h2 id="执行beanfactorypostprocessor">执行BeanFactoryPostProcessor</h2> <blockquote> <p>BeanFactoryPostProcessor是beanFactory的后置处理器</p> <ul> <li> <p>BeanFactoryPostProcessor是beanFactory的后置处理器，在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容，所有的bean定义已经保存加载到beanFactory，但是bean的实例还未创建</p> </li> <li> <p>执行BeanFactoryPostProcessor分两步，先执行BeanDefinitionRegistryPostProcessor，后执行BeanFactoryPostProcessor</p> </li> </ul> </blockquote> <ol start="5"> <li> <p><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：执行<code>BeanFactoryPostProcessor</code>的方法。<code>BeanFactoryPostProcessor</code>：<code>BeanFactory</code>的后置处理器。在<code>BeanFactory</code>标准初始化（以上4步）之后执行的，两个接口：<code>BeanFactoryPostProcessor</code>、<code>BeanDefinitionRegistryPostProcessor</code></p> <ol> <li> <p>执行<code>BeanFactoryPostProcessor</code>的方法</p> <ul> <li> <p>先执行<code>BeanDefinitionRegistryPostProcessor</code></p> <ol> <li> <p>获取所有的<code>BeanDefinitionRegistryPostProcessor</code></p> </li> <li> <p>看先执行实现了<code>PriorityOrdered</code>优先级接口的<code>BeanDefinitionRegistryPostProcessor</code></p> <p><code>postProcessor.postProcessBeanDefinitionRegistry(registry)</code></p> </li> <li> <p>再执行实现了<code>Ordered</code>顺序接口的<code>BeanDefinitionRegistryPostProcessor</code></p> <p><code>postProcessor.postProcessBeanDefinitionRegistry(registry)</code></p> </li> <li> <p>最后执行没有实现任何优先级或者是顺序接口的<code>BeanDefinitionRegistryPostProcessors</code></p> <p><code>postProcessor.postProcessBeanDefinitionRegistry(registry)</code></p> </li> </ol> </li> <li> <p>再执行<code>BeanFactoryPostProcessor</code>的方法</p> <ol> <li> <p>获取所有的<code>BeanFactoryPostProcessor</code></p> </li> <li> <p>看先执行实现了<code>PriorityOrdered</code>优先级接口的<code>BeanFactoryPostProcessor</code></p> <p><code>postProcessor.postProcessBeanFactory()</code></p> </li> <li> <p>再执行实现了<code>Ordered</code>顺序接口的<code>BeanFactoryPostProcessor</code></p> <p><code>postProcessor.postProcessBeanFactory()</code></p> </li> <li> <p>最后执行没有实现任何优先级或者是顺序接口的<code>BeanFactoryPostProcessor</code></p> <p><code>postProcessor.postProcessBeanFactory()</code></p> </li> </ol> </li> </ul> </li> </ol> </li> </ol> <h2 id="注册beanpostprocessor">注册BeanPostProcessor</h2> <blockquote> <p>按照优先级注册后置处理器，不执行</p> </blockquote> <ol start="6"> <li> <p><code>registerBeanPostProcessors(beanFactory)</code>：注册<code>BeanPostProcessor</code>（Bean的后置处理器）拦截Bean的创建</p> <p>不同接口类型的<code>BeanPostProcessor</code>，在Bean创建前后的执行时机是不一样的</p> <ul> <li> <p><code>BeanPostProcessor</code>后置处理器</p> </li> <li> <p><code>DestructionAwareBeanPostProcessor</code>销毁感知后置处理器</p> </li> <li> <p><code>InstantiationAwareBeanPostProcessor</code>实例化感知后置处理器</p> </li> <li> <p><code>SmartInstantiationAwareBeanPostProcessor</code>智能实例化感知后置处理器</p> </li> <li> <p><code>MergedBeanDefinitionPostProcessor[internalPostProcessors]</code>合并Bean定义信息后置处理器</p> </li> </ul> <ol> <li> <p>获取所有的<code>BeanPostProcessor</code>，后置处理器都默认可以通过<code>PriorityOrdered</code>、<code>Ordered</code>接口来执行优先级</p> </li> <li> <p>先注册<code>PriorityOrdered</code>优先级接口的<code>BeanPostProcessor</code></p> <p>把每一个<code>BeanPostProcessor</code>添加到<code>BeanFactory</code>中，<code>beanFactory.addBeanPostProcessor(postProcessor)</code></p> </li> <li> <p>再注册<code>Ordered</code>接口的</p> </li> <li> <p>最后注册没有实现任何优先级接口的</p> </li> <li> <p>最终注册<code>MergedBeanDefinitionPostProcessor</code></p> </li> <li> <p>注册一个<code>ApplicationListenerDetector</code>，来在Bean创建完成后检查是否是<code>ApplicationListener</code>，如果是就添加组件<code>applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean)</code></p> </li> </ol> </li> </ol> <h2 id="初始化messagesource">初始化MessageSource</h2> <blockquote> <p>国际化</p> </blockquote> <ol start="7"> <li> <p><code>initMessageSource()</code>：初始化<code>MessageSource</code>组件（做国际化功能；消息绑定，消息解析）</p> <ol> <li> <p>获取<code>BeanFactory</code></p> </li> <li> <p>看容器中是否有id为<code>messageSource</code>的，类型是<code>MessageSource</code>的组件，如果有赋值给<code>messageSource</code>，如果没有自己创建一个<code>DelegatingMessageSource</code></p> <p><code>MessageSource</code>：取出国际化配置文件中的某个key的值；能按照区域信息获取</p> </li> <li> <p>把创建好的<code>MessageSource</code>注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入<code>MessageSource</code></p> <p><code>beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource)</code></p> <p><code>MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale)</code></p> </li> </ol> </li> </ol> <h2 id="初始化事件派发器监听器">初始化事件派发器、监听器</h2> <ol start="8"> <li> <p><code>initApplicationEventMulticaster()</code>：初始化事件派发器</p> <ol> <li>获取<code>BeanFactory</code> </li> <li>从<code>BeanFactory</code>中获取<code>applicationEventMulticaster</code>的<code>ApplicationEventMulticaster</code> </li> <li>如果上一步没有配置，就创建一个<code>SimpleApplicationEventMulticaster</code> </li> <li>将创建的<code>ApplicationEventMulticaster</code>添加到<code>BeanFactory</code>中，以后其他组件直接自动注入</li> </ol> </li> <li> <p><code>onRefresh()</code>：留给子容器（子类）</p> <ol> <li>子类重写这个方法，在容器刷新的时候可以自定义逻辑；</li> </ol> </li> <li> <p><code>registerListeners()</code>：给容器中将所有项目里面的<code>ApplicationListener</code>注册进来；</p> <ol> <li> <p>从容器中拿到所有的<code>ApplicationListener</code></p> </li> <li> <p>将每个监听器添加到事件派发器中</p> <p><code>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName)</code></p> </li> <li> <p>派发之前步骤产生的事件</p> </li> </ol> </li> </ol> <h2 id="创建bean准备完成">创建Bean准备、完成</h2> <blockquote> <p>有代理对象就用，没有就创建，然后在初始化前后准备各种后置处理器，创建完成后放入各种Map</p> </blockquote> <ol start="11"> <li> <p><code>finishBeanFactoryInitialization(beanFactory)</code>：初始化所有剩下的单实例bean</p> <ol> <li> <p><code>beanFactory.preInstantiateSingletons()</code>：初始化剩下的单实例bean</p> <ol> <li> <p>获取容器中的所有Bean，依次进行初始化和创建对象</p> </li> <li> <p>获取Bean的定义信息：<code>RootBeanDefinition</code></p> </li> <li> <p>判断Bean不是抽象的，是单实例的，不是懒加载</p> <ol> <li> <p>判断是否是<code>FactoryBean</code>，是否是实现<code>FactoryBean</code>接口的Bean</p> </li> <li> <p>如果不是工厂Bean。利用<code>getBean(beanName)</code>：创建对象</p> <ol> <li> <p>这个<code>getBean(beanName)</code>就是平时测试类中用到的<code>ioc.getBean()</code></p> </li> <li> <p><code>doGetBean(name, null, null, false)</code></p> </li> <li> <p>先获取缓存中保存的单实例Bean。<code>this.singletonObjects.get(beanName)</code>，如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）</p> <p>可以从<code>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256)</code>属性获取到</p> </li> <li> <p>缓存中获取不到，开始Bean的创建对象流程，使用<code>BeanFactory</code></p> </li> <li> <p>标记当前bean已经被创建<code>markBeanAsCreated(beanName)</code></p> </li> <li> <p>获取Bean的定义信息</p> </li> <li> <p><font color="red">【获取当前Bean依赖的其他Bean，<code>mbd.getDependsOn()</code>，如果有按照就getBean()把依赖的Bean先创建出来】</font></p> </li> <li> <p><font color="red">启动单实例Bean的创建流程</font></p> <ol> <li> <p>进入匿名类的<code>createBean(beanName, mbd, args)</code>方法（可以打断点进入）</p> </li> <li> <p><code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse)[给 BeanPostProcessors 一个返回代理而不是目标 Bean 实例的机会]</code>：让<code>BeanPostProcessor</code>先拦截返回代理对象</p> <p><font color="red">【<code>InstantiationAwareBeanPostProcessor</code>提前执行，就是在AOP中先于<code>BeanPostProcessor</code>执行的那个组件】</font></p> <ul> <li>先触发：<code>postProcessBeforeInstantiation()实例化前的后处理</code> </li> <li>如果有返回值，触发：<code>postProcessAfterInitialization()初始化后的后处理</code> </li> </ul> </li> <li> <p>如果前面的<code>InstantiationAwareBeanPostProcessor</code>没有返回代理对象，调用第4步创建Bean</p> </li> <li> <p><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>：创建Bean</p> <ol> <li> <p><font color="red">【创建Bean实例】</font>：<code>createBeanInstance(beanName, mbd, args)</code></p> <p>利用工厂方法或者对象的构造器创建出Bean实例</p> </li> <li> <p><code>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName)[允许后处理器修改合并的 Bean 定义。]</code></p> <p>调用<code>MergedBeanDefinitionPostProcessor</code>的<code>postProcessMergedBeanDefinition(mbd, beanType, beanName)</code></p> </li> <li> <p><font color="red">【Bean属性赋值】</font><code>populateBean(beanName, mbd, instanceWrapper)</code></p> <p>赋值之前：</p> <ol> <li> <p>拿到<code>InstantiationAwareBeanPostProcessor</code>后置处理器：</p> <p><code>postProcessAfterInstantiation()</code>实例化后的后处理（对应上面（8.2））</p> </li> <li> <p>拿到<code>InstantiationAwareBeanPostProcessor</code>后置处理器：</p> <p><code>ibp.postProcessPropertyValues()</code>后处理属性值</p> </li> </ol> <p>开始赋值：</p> <ol start="3"> <li> <p>应用Bean属性的值；为属性利用setter方法等进行赋值：</p> <p><code>applyPropertyValues(beanName, mbd, bw, pvs)</code></p> </li> </ol> </li> <li> <p><font color="red">【Bean初始化】</font><code>initializeBean(beanName, exposedObject, mbd)</code>：</p> <ol> <li> <p><font color="red">【执行Aware接口方法】</font><code>invokeAwareMethods(beanName, bean)</code>：执行<code>xxxAware</code>接口的方法，如<code>BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</code></p> </li> <li> <p><font color="red">【在初始化之前应用 BeanPostProcessors】</font><code>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)</code></p> <p><code>BeanPostProcessor.postProcessBeforeInitialization()</code></p> </li> <li> <p><font color="red">【执行初始化方法】</font><code>invokeInitMethods(beanName, wrappedBean, mbd)</code></p> <ol> <li>是否是<code>InitializingBean</code>接口的实现；执行接口规定的初始化</li> <li>是否自定义初始化方法</li> </ol> </li> <li> <p><font color="red">【在初始化之后应用 BeanPostProcessors】</font><code>applyBeanPostProcessorsAfterInitialization</code></p> <p><code>BeanPostProcessor.postProcessAfterInitialization()</code></p> </li> </ol> </li> <li> <p>注册Bean的销毁方法</p> </li> </ol> </li> <li> <p>将创建的Bean添加到缓存中<code>singletonObjects</code></p> </li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> </ol> </li> </ol> <p><font color="red"><strong>ioc容器就是这些Map，很多的Map里面保存了单实例Bean，环境信息...</strong></font></p> <p>所有Bean都利用getBean创建完成以后：检查所有的Bean是否是<code>SmartInitializingSingleton[智能初始化单例]</code>接口的，如果是，就执行<code>afterSingletonsInstantiated()在单例实例化之后</code></p> <h2 id="容器创建完成">容器创建完成</h2> <ol start="12"> <li> <p><code>finishRefresh()</code>：完成<code>BeanFactory</code>的初始化创建工作，IOC容器就创建完成</p> <ol> <li> <p><code>initLifecycleProcessor()</code>：初始化和生命周期有关的后置处理器：<code>LifecycleProcessor</code></p> <ol> <li> <p>默认从容器中找是否有<code>lifecycleProcessor</code>的组件【<code>LifecycleProcessor</code>】；</p> </li> <li> <p>如果没有<code>new DefaultLifecycleProcessor()</code>;</p> </li> <li> <p>加入到容器<code>onRefresh()</code></p> <p>写一个<code>LifecycleProcessor</code>的实现类，可以在<code>BeanFactory</code>的生命周期<code>onRefresh()</code>、<code>onClose()</code>处拦截</p> </li> </ol> </li> <li> <p><code>getLifecycleProcessor().onRefresh()</code></p> <p>拿到前面定义的生命周期处理器（<code>BeanFactory</code>），回调<code>onRefresh()</code></p> </li> <li> <p><code>publishEvent(new ContextRefreshedEvent(this))</code>：发布容器刷新完成事件</p> </li> <li> <p><code>LiveBeansView.registerApplicationContext(this)</code></p> </li> </ol> </li> </ol> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-25401.htm">厦门有没有宠物领养中心（厦门宠物救助领养中心地址）</a></p>
                                        <p>下一个：<a href="/news/article-25869.htm">宠物用品批发零售店（宠物用品批发零售店赚钱吗）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-21678.htm" title="smdms超市订单管理系统之登录功能">smdms超市订单管理系统之登录功能</a></li>
                        <li class="py-2"><a href="/news/article-46646.htm" title="springboot中emoji表情配置及springboot数据源配置区别">springboot中emoji表情配置及springboot数据源配置区别</a></li>
                        <li class="py-2"><a href="/news/article-34825.htm" title="北京最新免费领养狗狗 北京最新免费领养狗狗贴吧">北京最新免费领养狗狗 北京最新免费领养狗狗贴吧</a></li>
                        <li class="py-2"><a href="/news/article-28183.htm" title="猫三联疫苗价格表（猫三联疫苗价钱）">猫三联疫苗价格表（猫三联疫苗价钱）</a></li>
                        <li class="py-2"><a href="/news/article-43158.htm" title="动态修改springboot中的scheduling(动态修改定时任务执行时间)">动态修改springboot中的scheduling(动态修改定时任务执行时间)</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-15-node-share.htm" title="「11月15日」最高速度23M/S，2024年V2ray/Shadowrocket/Clash/SSR每天更新免费节点订阅链接">「11月15日」最高速度23M/S，2024年V2ray/Shadowrocket/Clash/SSR每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-33868.htm" title="隔衣服被猫抓了一下红色划痕要***吗（隔着衣服被猫抓伤了）">隔衣服被猫抓了一下红色划痕要***吗（隔着衣服被猫抓伤了）</a></li>
                        <li class="py-2"><a href="/news/article-42666.htm" title="北京农业大学动物医院电话号码查询（北京农业大学动物医院电话号码查询）">北京农业大学动物医院电话号码查询（北京农业大学动物医院电话号码查询）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-30-free-node-subscribe.htm" title="「11月30日」最高速度19.9M/S，2024年SSR/Shadowrocket/Clash/V2ray每天更新免费节点订阅链接">「11月30日」最高速度19.9M/S，2024年SSR/Shadowrocket/Clash/V2ray每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-22170.htm" title="PowerBI开发：用自然语言来探索数据&#8211;Q&amp;A">PowerBI开发：用自然语言来探索数据&#8211;Q&amp;A</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">6</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div> <!-- .container -->
    </div> <!-- .page-section -->
        <footer class="page-footer bg-image" style="background-image: url(/assets/website/img/clashstash/world_pattern.svg);">
        <div class="container">
            <p class="text-center" id="copyright">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                <a href="/">ClashStash官方节点站</a> 版权所有
                <br />Powered by WordPress
            </p>
        </div>
    </footer>
    <script src="/assets/website/js/frontend/clashstash/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/clashstash/bootstrap.bundle.min.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>