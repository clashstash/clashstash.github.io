<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://clashstash.github.io/news/article-66657.htm" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>深入浅出Java线程池原理分析与使用</title>
        <meta name="description" content="在我们的开发中“池”的概念并不罕见，有数据库连接池、线程池、对象池、常量池等等。下面我们主要针对线程池来一步一步揭开线程池的面纱。 使用线程池的好处 1、降低资源消耗 可以重复利用已创建的线程降低线程" />
        <link rel="icon" href="/assets/website/img/clashstash/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="ClashStash官方节点站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://clashstash.github.io/news/article-66657.htm" />
    <meta property="og:site_name" content="ClashStash官方节点站" />
    <meta property="og:title" content="深入浅出Java线程池原理分析与使用" />
    <meta property="og:image" content="https://clashstash.github.io/uploads/20240709/bf701bb32caac94df0a8b9b73516f6d1.webp" />
        <meta property="og:release_date" content="2025-03-03T08:15:00" />
    <meta property="og:updated_time" content="2025-03-03T08:15:00" />
        <meta property="og:description" content="在我们的开发中“池”的概念并不罕见，有数据库连接池、线程池、对象池、常量池等等。下面我们主要针对线程池来一步一步揭开线程池的面纱。 使用线程池的好处 1、降低资源消耗 可以重复利用已创建的线程降低线程" />
        
    <link rel="stylesheet" href="/assets/website/css/clashstash/maicons.css">
    <link rel="stylesheet" href="/assets/website/css/clashstash/bootstrap.css">
    <link rel="stylesheet" href="/assets/website/css/clashstash/theme.css">

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="深入浅出Java线程池原理分析与使用">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FGG26WJLQX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FGG26WJLQX');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
    <!-- Back to top button -->
    <div class="back-to-top"></div>
    <header>
                <nav class="navbar navbar-expand-lg navbar-light bg-white sticky" data-offset="500">
            <div class="container">
                                <a href="/" class="navbar-brand">Clash<span class="text-primary">Stash</span></a>
                                <button class="navbar-toggler" data-toggle="collapse" data-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="navbar-collapse collapse" id="navbarContent">
                    <ul class="navbar-nav ml-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/free-nodes/">免费节点</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/paid-subscribe/">推荐机场</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/client.htm">客户端</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/news/">新闻资讯</a>
                        </li>
                                            </ul>
                </div>
            </div>
        </nav>
        <div class="container">
            <div class="page-banner">
                <div class="row justify-content-center align-items-center h-100">
                    <div class="col-md-6">
                        <nav aria-label="Breadcrumb">
                            <ul class="breadcrumb justify-content-center py-0 bg-transparent">
                                <li class="breadcrumb-item"><a href="/">首页</a></li>
                                <li class="breadcrumb-item"><a href="/news/">新闻资讯</a></li>
                                <li class="breadcrumb-item active">正文</li>
                            </ul>
                        </nav>
                        <h1 class="text-center">深入浅出Java线程池原理分析与使用</h1>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <div class="page-section" id="about">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <div class="article-content"> <p>在我们的开发中“池”的概念并不罕见，有数据库连接池、线程池、对象池、常量池等等。下面我们主要针对线程池来一步一步揭开线程池的面纱。</p> <h2>使用线程池的好处</h2> <p><b>1、降低资源消耗</b></p> <p>可以重复利用已创建的线程降低线程创建和销毁造成的消耗。</p> <p><b>2、提高响应速度</b></p> <p>当任务到达时，任务可以不需要等到线程创建就能立即执行。</p> <p><b>3、提高线程的可管理性</b></p> <p>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</p> <h2>线程池的工作原理</h2> <p>首先我们看下当一个新的任务提交到线程池之后，线程池是如何处理的</p> <p>1、线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步。</p> <p>2、线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步</p> <p>3、线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</p> <h2>线程池饱和策略</h2> <p>这里提到了线程池的饱和策略，那我们就简单介绍下有哪些饱和策略：</p> <p><b>AbortPolicy</b></p> <p>为Java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPool<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://link.juejin.im?target=http%3A%2F%2Fwww.codeceo.com%2Farticle%2Fjava-executor-learning.html"  rel="nofollow">Executor</a>.execute需要try catch，否则程序会直接退出。</p> <p><b>DiscardPolicy</b></p> <p>直接抛弃，任务不执行，空方法</p> <p><b>DiscardOldestPolicy</b></p> <p>从队列里面抛弃head的一个任务，并再次execute 此task。</p> <p><b>CallerRunsPolicy</b></p> <p>在调用execute的线程里面执行此command，会阻塞入口</p> <p><b>用户自定义拒绝策略（最常用）</b></p> <p>实现RejectedExecutionHandler，并自己定义策略模式</p> <p>下我们以ThreadPoolExecutor为例展示下线程池的工作流程图</p> <p>1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p> <p>2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p> <p>3、如果无法将任务加入BlockingQueue（队列已满），则在非corePool中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</p> <p>4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p> <p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p> <p>线程池只是并发编程中的一小部分，下图是一份全面的Java的并发编程学习技术总汇，在互联网公司面试中，并发编程一定是面试官会问到的问题大家需要学习一下。</p> </p> <p>想学习大数据或者对大数据技术感兴趣的朋友，我整理了一套大数据的学习视频免费分享给大家，从入门到实战都有，大家可以加我的微信：Lxiao_28获取！（备注领取资料）</p> <h2>关键方法源码分析</h2> <p>我们看看核心方法添加到线程池方法execute的源码如下：</p> <pre class="hljs cs"><code class="hljs cs copyable" lang="cs"><span class="hljs-comment">//</span>      <span class="hljs-comment">//Executes the given task sometime in the future.  The task</span>      <span class="hljs-comment">//may execute in a new thread or in an existing pooled thread.</span>      <span class="hljs-comment">//</span>      <span class="hljs-comment">// If the task cannot be submitted for execution, either because this</span>      <span class="hljs-comment">// executor has been shutdown or because its capacity has been reached,</span>      <span class="hljs-comment">// the task is handled by the current {@code RejectedExecutionHandler}.</span>      <span class="hljs-comment">//</span>      <span class="hljs-comment">// @param command the task to execute</span>      <span class="hljs-comment">// @throws RejectedExecutionException at discretion of</span>      <span class="hljs-comment">//         {@code RejectedExecutionHandler}, if the task</span>      <span class="hljs-comment">//         cannot be accepted for execution</span>      <span class="hljs-comment">// @throws NullPointerException if {@code command} is null</span>      <span class="hljs-comment">//</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>(<span class="hljs-params">Runnable command</span>) </span>{         <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();         <span class="hljs-comment">//</span>          <span class="hljs-comment">// Proceed in 3 steps:</span>          <span class="hljs-comment">//</span>          <span class="hljs-comment">// 1. If fewer than corePoolSize threads are running, try to</span>          <span class="hljs-comment">// start a new thread with the given command as its first</span>          <span class="hljs-comment">// task.  The call to addWorker atomically checks runState and</span>          <span class="hljs-comment">// workerCount, and so prevents false alarms that would add</span>          <span class="hljs-comment">// threads when it shouldn't, by returning false.</span>          <span class="hljs-comment">// 翻译如下：</span>          <span class="hljs-comment">// 判断当前的线程数是否小于corePoolSize如果是，使用入参任务通过addWord方法创建一个新的线程，</span>          <span class="hljs-comment">// 如果能完成新线程创建exexute方法结束，成功提交任务</span>          <span class="hljs-comment">// 2. If a task can be successfully queued, then we still need</span>          <span class="hljs-comment">// to double-check whether we should have added a thread</span>          <span class="hljs-comment">// (because existing ones died since last checking) or that</span>          <span class="hljs-comment">// the pool shut down since entry into this method. So we</span>          <span class="hljs-comment">// recheck state and if necessary roll back the enqueuing if</span>          <span class="hljs-comment">// stopped, or start a new thread if there are none.</span>          <span class="hljs-comment">// 翻译如下：</span>          <span class="hljs-comment">// 在第一步没有完成任务提交；状态为运行并且能否成功加入任务到工作队列后，再进行一次check，如果状态</span>          <span class="hljs-comment">// 在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要</span>          <span class="hljs-comment">// reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</span>          <span class="hljs-comment">// 3. If we cannot queue task, then we try to add a new</span>          <span class="hljs-comment">// thread.  If it fails, we know we are shut down or saturated</span>          <span class="hljs-comment">// and so reject the task.</span>          <span class="hljs-comment">// 翻译如下：</span>          <span class="hljs-comment">// 如果不能加入任务到工作队列，将尝试使用任务新增一个线程，如果失败，则是线程池已经shutdown或者线程池</span>          <span class="hljs-comment">// 已经达到饱和状态，所以reject这个他任务</span>          <span class="hljs-comment">//</span>         <span class="hljs-keyword">int</span> c = ctl.<span class="hljs-keyword">get</span>();         <span class="hljs-comment">// 工作线程数小于核心线程数</span>         <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {             <span class="hljs-comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span>             <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))                 <span class="hljs-keyword">return</span>;             c = ctl.<span class="hljs-keyword">get</span>();         }         <span class="hljs-comment">// 如果工作线程数大于等于核心线程数</span>         <span class="hljs-comment">// 线程的的状态未RUNNING并且队列notfull</span>         <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) {             <span class="hljs-comment">// 再次检查线程的运行状态，如果不是RUNNING直接从队列中移除</span>             <span class="hljs-keyword">int</span> recheck = ctl.<span class="hljs-keyword">get</span>();             <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="hljs-keyword">remove</span>(command))                 <span class="hljs-comment">// 移除成功，拒绝该非运行的任务</span>                 reject(command);             <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> (<span class="hljs-params">workerCountOf(recheck</span>) </span>== <span class="hljs-number">0</span>)                 <span class="hljs-comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span>                 <span class="hljs-comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span>                 addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);         }         <span class="hljs-comment">// 如果队列满了或者是非运行的任务都拒绝执行</span>         <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> (<span class="hljs-params">!addWorker(command, <span class="hljs-literal">false</span></span>))             <span class="hljs-title">reject</span>(<span class="hljs-params">command</span>)</span>;     }<span class="copy-code-btn">复制代码</span></code></pre> <p>下面我们继续看看addWorker是如何实现的：</p> <pre><code class="language-java"><code class="hljs java copyable"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>{         <span class="hljs-comment">// java标签</span>         retry:         <span class="hljs-comment">// 死循环</span>         <span class="hljs-keyword">for</span> (;;) {             <span class="hljs-keyword">int</span> c = ctl.get();             <span class="hljs-comment">// 获取当前线程状态</span>             <span class="hljs-keyword">int</span> rs = runStateOf(c);             <span class="hljs-comment">// Check if queue empty only if necessary.</span>             <span class="hljs-comment">// 这个逻辑判断有点绕可以改成 </span>             <span class="hljs-comment">// rs &gt;= shutdown &amp;&amp; (rs != shutdown || firstTask != null || workQueue.isEmpty())</span>             <span class="hljs-comment">// 逻辑判断成立可以分为以下几种情况均不接受新任务</span>             <span class="hljs-comment">// 1、rs &gt; shutdown:--不接受新任务</span>             <span class="hljs-comment">// 2、rs &gt;= shutdown &amp;&amp; firstTask != null:--不接受新任务</span>             <span class="hljs-comment">// 3、rs &gt;= shutdown &amp;&amp; workQueue.isEmppty:--不接受新任务</span>             <span class="hljs-comment">// 逻辑判断不成立</span>             <span class="hljs-comment">// 1、rs==shutdown&amp;&amp;firstTask != null:此时不接受新任务，但是仍会执行队列中的任务</span>             <span class="hljs-comment">// 2、rs==shotdown&amp;&amp;firstTask == null:会执行addWork(null,false)</span>             <span class="hljs-comment">//  防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span>             <span class="hljs-comment">//  添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span>             <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span> &amp;&amp;! workQueue.isEmpty()))                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;             <span class="hljs-comment">// 死循环</span>             <span class="hljs-comment">// 如果线程池状态为RUNNING并且队列中还有需要执行的任务</span>             <span class="hljs-keyword">for</span> (;;) {                 <span class="hljs-comment">// 获取线程池中线程数量</span>                 <span class="hljs-keyword">int</span> wc = workerCountOf(c);                 <span class="hljs-comment">// 如果超出容量或者最大线程池容量不在接受新任务</span>                 <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))                     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                 <span class="hljs-comment">// 线程安全增加工作线程数</span>                 <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                     <span class="hljs-comment">// 跳出retry</span>                     <span class="hljs-keyword">break</span> retry;                 c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>                 <span class="hljs-comment">// 如果线程池状态发生变化，重新循环</span>                 <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                     <span class="hljs-keyword">continue</span> retry;                 <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>             }         }          <span class="hljs-comment">// 走到这里说明工作线程数增加成功</span>         <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;         Worker w = <span class="hljs-keyword">null</span>;         <span class="hljs-keyword">try</span> {             <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;             w = <span class="hljs-keyword">new</span> Worker(firstTask);             <span class="hljs-keyword">final</span> Thread t = w.thread;             <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) {                 <span class="hljs-comment">// 加锁</span>                 mainLock.lock();                 <span class="hljs-keyword">try</span> {                     <span class="hljs-comment">// Recheck while holding lock.</span>                     <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                     <span class="hljs-comment">// shut down before lock acquired.</span>                     <span class="hljs-keyword">int</span> c = ctl.get();                     <span class="hljs-keyword">int</span> rs = runStateOf(c);                     <span class="hljs-comment">// RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</span>                     <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                         (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) {                         <span class="hljs-comment">// 检查线程状态</span>                         <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                         <span class="hljs-comment">// 将新启动的线程添加到线程池中</span>                         workers.add(w);                         <span class="hljs-comment">// 更新线程池线程数且不超过最大值</span>                         <span class="hljs-keyword">int</span> s = workers.size();                         <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                             largestPoolSize = s;                         workerAdded = <span class="hljs-keyword">true</span>;                     }                 } <span class="hljs-keyword">finally</span> {                     mainLock.unlock();                 }                 <span class="hljs-comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span>                 <span class="hljs-keyword">if</span> (workerAdded) {                     <span class="hljs-comment">//执行ThreadPoolExecutor的runWoker方法</span>                     t.start();                     workerStarted = <span class="hljs-keyword">true</span>;                 }             }         } <span class="hljs-keyword">finally</span> {             <span class="hljs-comment">// 线程启动失败，则从wokers中移除w并递减wokerCount</span>             <span class="hljs-keyword">if</span> (! workerStarted)                 <span class="hljs-comment">// 递减wokerCount会触发tryTerminate方法</span>                 addWorkerFailed(w);         }         <span class="hljs-keyword">return</span> workerStarted;     }<span class="copy-code-btn">复制代码</span></code></code></pre> <p>addWorker之后是runWorker,第一次启动会执行初始化传进来的任务firstTask；然后会从workQueue中取任务执行，如果队列为空则等待keepAliveTime这么长时间</p> <pre class="hljs gradle"><code class="hljs gradle copyable"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> runWorker(Worker w) {         Thread wt = Thread.currentThread();         Runnable <span class="hljs-keyword">task</span> = w.firstTask;         w.firstTask = <span class="hljs-keyword">null</span>;         <span class="hljs-comment">// 允许中断</span>         w.unlock(); <span class="hljs-comment">// allow interrupts</span>         <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;         <span class="hljs-keyword">try</span> {             <span class="hljs-comment">// 如果getTask返回null那么getTask中会将workerCount递减，如果异常了这个递减操作会在processWorkerExit中处理</span>             <span class="hljs-keyword">while</span> (<span class="hljs-keyword">task</span> != <span class="hljs-keyword">null</span> || (<span class="hljs-keyword">task</span> = getTask()) != <span class="hljs-keyword">null</span>) {                 w.lock();                 <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span>                 <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span>                 <span class="hljs-comment">// requires a recheck in second case to deal with</span>                 <span class="hljs-comment">// shutdownNow race while clearing interrupt</span>                 <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||                      (Thread.interrupted() &amp;&amp;                       runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                     !wt.isInterrupted())                     wt.interrupt();                 <span class="hljs-keyword">try</span> {                     beforeExecute(wt, <span class="hljs-keyword">task</span>);                     Throwable thrown = <span class="hljs-keyword">null</span>;                     <span class="hljs-keyword">try</span> {                         <span class="hljs-keyword">task</span>.run();                     } <span class="hljs-keyword">catch</span> (RuntimeException x) {                         thrown = x; <span class="hljs-keyword">throw</span> x;                     } <span class="hljs-keyword">catch</span> (Error x) {                         thrown = x; <span class="hljs-keyword">throw</span> x;                     } <span class="hljs-keyword">catch</span> (Throwable x) {                         thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);                     } <span class="hljs-keyword">finally</span> {                         afterExecute(<span class="hljs-keyword">task</span>, thrown);                     }                 } <span class="hljs-keyword">finally</span> {                     <span class="hljs-keyword">task</span> = <span class="hljs-keyword">null</span>;                     w.completedTasks++;                     w.unlock();                 }             }             completedAbruptly = <span class="hljs-keyword">false</span>;         } <span class="hljs-keyword">finally</span> {             processWorkerExit(w, completedAbruptly);         }     }<span class="copy-code-btn">复制代码</span></code></pre> <p>我们看下getTask是如何执行的</p> <pre class="hljs kotlin"><code class="hljs kotlin copyable"><span class="hljs-keyword">private</span> Runnable getTask() {         boolean timedOut = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span>         <span class="hljs-comment">// 死循环</span>         retry: <span class="hljs-keyword">for</span> (;;) {             <span class="hljs-comment">// 获取线程池状态</span>             int c = ctl.<span class="hljs-keyword">get</span>();             int rs = runStateOf(c);             <span class="hljs-comment">// Check if queue empty only if necessary.</span>             <span class="hljs-comment">// 1.rs &gt; SHUTDOWN 所以rs至少等于STOP,这时不再处理队列中的任务</span>             <span class="hljs-comment">// 2.rs = SHUTDOWN 所以rs&gt;=STOP肯定不成立，这时还需要处理队列中的任务除非队列为空</span>             <span class="hljs-comment">// 这两种情况都会返回null让runWoker退出while循环也就是当前线程结束了，所以必须要decrement</span>             <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {                 <span class="hljs-comment">// 递减workerCount值</span>                 decrementWorkerCount();                 <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;             }             <span class="hljs-comment">// 标记从队列中取任务时是否设置超时时间</span>             boolean timed; <span class="hljs-comment">// Are workers subject to culling?</span>             <span class="hljs-comment">// 1.RUNING状态</span>             <span class="hljs-comment">// 2.SHUTDOWN状态，但队列中还有任务需要执行</span>             <span class="hljs-keyword">for</span> (;;) {                 int wc = workerCountOf(c);                 <span class="hljs-comment">// 1.core thread允许被超时，那么超过corePoolSize的的线程必定有超时</span>                 <span class="hljs-comment">// 2.allowCoreThreadTimeOut == false &amp;&amp; wc &gt;</span>                 <span class="hljs-comment">// corePoolSize时，一般都是这种情况，core thread即使空闲也不会被回收，只要超过的线程才会</span>                 timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;                 <span class="hljs-comment">// 从addWorker可以看到一般wc不会大于maximumPoolSize，所以更关心后面半句的情形：</span>                 <span class="hljs-comment">// 1. timedOut == false 第一次执行循环， 从队列中取出任务不为null方法返回 或者</span>                 <span class="hljs-comment">// poll出异常了重试</span>                 <span class="hljs-comment">// 2.timeOut == true &amp;&amp; timed ==</span>                 <span class="hljs-comment">// false:看后面的代码workerQueue.poll超时时timeOut才为true，</span>                 <span class="hljs-comment">// 并且timed要为false，这两个条件相悖不可能同时成立（既然有超时那么timed肯定为true）</span>                 <span class="hljs-comment">// 所以超时不会继续执行而是return null结束线程。</span>                 <span class="hljs-keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; !(timedOut &amp;&amp; timed))                     <span class="hljs-keyword">break</span>;                 <span class="hljs-comment">// workerCount递减，结束当前thread</span>                 <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))                     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                 c = ctl.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// Re-read ctl</span>                 <span class="hljs-comment">// 需要重新检查线程池状态，因为上述操作过程中线程池可能被SHUTDOWN</span>                 <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                     <span class="hljs-keyword">continue</span> retry;                 <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>             }             <span class="hljs-keyword">try</span> {                 <span class="hljs-comment">// 1.以指定的超时时间从队列中取任务</span>                 <span class="hljs-comment">// 2.core thread没有超时</span>                 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();                 <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)                     <span class="hljs-keyword">return</span> r;                 timedOut = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 超时</span>             } <span class="hljs-keyword">catch</span> (InterruptedException retry) {                 timedOut = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 线程被中断重试</span>             }         }     }<span class="copy-code-btn">复制代码</span></code></pre> <p>下面我们看下processWorkerExit是如何工作的</p> <pre><code class="language-java"><code class="hljs java copyable"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>{         <span class="hljs-comment">// 正常的话再runWorker的getTask方法workerCount已经被减一了</span>         <span class="hljs-keyword">if</span> (completedAbruptly)             decrementWorkerCount();         <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;         mainLock.lock();         <span class="hljs-keyword">try</span> {             <span class="hljs-comment">// 累加线程的completedTasks</span>             completedTaskCount += w.completedTasks;             <span class="hljs-comment">// 从线程池中移除超时或者出现异常的线程</span>             workers.remove(w);         } <span class="hljs-keyword">finally</span> {             mainLock.unlock();         }         <span class="hljs-comment">// 尝试停止线程池</span>         tryTerminate();         <span class="hljs-keyword">int</span> c = ctl.get();         <span class="hljs-comment">// runState为RUNNING或SHUTDOWN</span>         <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) {             <span class="hljs-comment">// 线程不是异常结束</span>             <span class="hljs-keyword">if</span> (!completedAbruptly) {                 <span class="hljs-comment">// 线程池最小空闲数，允许core thread超时就是0，否则就是corePoolSize</span>                 <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;                 <span class="hljs-comment">// 如果min == 0但是队列不为空要保证有1个线程来执行队列中的任务</span>                 <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; !workQueue.isEmpty())                     min = <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 线程池还不为空那就不用担心了</span>                 <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)                     <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span>             }             <span class="hljs-comment">// 1.线程异常退出</span>             <span class="hljs-comment">// 2.线程池为空，但是队列中还有任务没执行，看addWoker方法对这种情况的处理</span>             addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);         }     }<span class="copy-code-btn">复制代码</span></code></code></pre> <p>tryTerminate</p> <p>processWorkerExit方法中会尝试调用tryTerminate来终止线程池。这个方法在任何可能导致线程池终止的动作后执行：比如减少wokerCount或SHUTDOWN状态下从队列中移除任务。</p> <pre class="hljs kotlin"><code class="hljs kotlin copyable"><span class="hljs-keyword">final</span> void tryTerminate() {         <span class="hljs-keyword">for</span> (;;) {             int c = ctl.<span class="hljs-keyword">get</span>();             <span class="hljs-comment">// 以下状态直接返回：</span>             <span class="hljs-comment">// 1.线程池还处于RUNNING状态</span>             <span class="hljs-comment">// 2.SHUTDOWN状态但是任务队列非空</span>             <span class="hljs-comment">// 3.runState &gt;= TIDYING 线程池已经停止了或在停止了</span>             <span class="hljs-keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))                 <span class="hljs-keyword">return</span>;             <span class="hljs-comment">// 只能是以下情形会继续下面的逻辑：结束线程池。</span>             <span class="hljs-comment">// 1.SHUTDOWN状态，这时不再接受新任务而且任务队列也空了</span>             <span class="hljs-comment">// 2.STOP状态，当调用了shutdownNow方法</span>             <span class="hljs-comment">// workerCount不为0则还不能停止线程池,而且这时线程都处于空闲等待的状态</span>             <span class="hljs-comment">// 需要中断让线程“醒”过来，醒过来的线程才能继续处理shutdown的信号。</span>             <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) { <span class="hljs-comment">// Eligible to terminate</span>                 <span class="hljs-comment">// runWoker方法中w.unlock就是为了可以被中断,getTask方法也处理了中断。</span>                 <span class="hljs-comment">// ONLY_ONE:这里只需要中断1个线程去处理shutdown信号就可以了。</span>                 interruptIdleWorkers(ONLY_ONE);                 <span class="hljs-keyword">return</span>;             }             <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;             mainLock.lock();             <span class="hljs-keyword">try</span> {                 <span class="hljs-comment">// 进入TIDYING状态</span>                 <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) {                     <span class="hljs-keyword">try</span> {                         <span class="hljs-comment">// 子类重载：一些资源清理工作</span>                         terminated();                     } <span class="hljs-keyword">finally</span> {                         <span class="hljs-comment">// TERMINATED状态</span>                         ctl.<span class="hljs-keyword">set</span>(ctlOf(TERMINATED, <span class="hljs-number">0</span>));                         <span class="hljs-comment">// 继续awaitTermination</span>                         termination.signalAll();                     }                     <span class="hljs-keyword">return</span>;                 }             } <span class="hljs-keyword">finally</span> {                 mainLock.unlock();             }             <span class="hljs-comment">// else retry on failed CAS</span>         }     }<span class="copy-code-btn">复制代码</span></code></pre> <p>shutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程。shutdownNow方法将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程。主要区别在于shutdown调用的是interruptIdleWorkers这个方法，而shutdownNow实际调用的是Worker类的interruptIfStarted方法：</p> <p>他们的实现如下：</p> <pre><code class="language-java"><code class="hljs java copyable"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>{         <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;         mainLock.lock();         <span class="hljs-keyword">try</span> {             checkShutdownAccess();             <span class="hljs-comment">// 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</span>             advanceRunState(SHUTDOWN);             <span class="hljs-comment">// 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</span>             <span class="hljs-comment">// tryTerminate方法中会保证队列中剩余的任务得到执行。</span>             interruptIdleWorkers();             onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>         } <span class="hljs-keyword">finally</span> {             mainLock.unlock();         }         tryTerminate();     } <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>{     List&lt;Runnable&gt; tasks;     <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;     mainLock.lock();     <span class="hljs-keyword">try</span> {         checkShutdownAccess();         <span class="hljs-comment">// STOP状态：不再接受新任务且不再执行队列中的任务。</span>         advanceRunState(STOP);         <span class="hljs-comment">// 中断所有线程</span>         interruptWorkers();         <span class="hljs-comment">// 返回队列中还没有被执行的任务。</span>         tasks = drainQueue();     }     <span class="hljs-keyword">finally</span> {         mainLock.unlock();     }     tryTerminate();     <span class="hljs-keyword">return</span> tasks; } <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>{     <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;     mainLock.lock();     <span class="hljs-keyword">try</span> {         <span class="hljs-keyword">for</span> (Worker w : workers) {             Thread t = w.thread;             <span class="hljs-comment">// w.tryLock能获取到锁，说明该线程没有在运行，因为runWorker中执行任务会先lock，</span>             <span class="hljs-comment">// 因此保证了中断的肯定是空闲的线程。</span>             <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) {                 <span class="hljs-keyword">try</span> {                     t.interrupt();                 } <span class="hljs-keyword">catch</span> (SecurityException ignore) {                 } <span class="hljs-keyword">finally</span> {                     w.unlock();                 }             }             <span class="hljs-keyword">if</span> (onlyOne)                 <span class="hljs-keyword">break</span>;         }     }     <span class="hljs-keyword">finally</span> {         mainLock.unlock();     } } <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interruptIfStarted</span><span class="hljs-params">()</span> </span>{     Thread t;     <span class="hljs-comment">// 初始化时state == -1</span>     <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-keyword">null</span> &amp;&amp; !t.isInterrupted()) {         <span class="hljs-keyword">try</span> {             t.interrupt();         } <span class="hljs-keyword">catch</span> (SecurityException ignore) {         }     } }<span class="copy-code-btn">复制代码</span></code></code></pre> <h2>线程池的使用</h2> <h3>线程池的创建</h3> <p>我们可以通过ThreadPoolExecutor来创建一个线程池</p> <pre><code class="language-java"><code class="hljs java copyable"><span class="hljs-comment">/**      * <span class="hljs-doctag">@param</span> corePoolSize 线程池基本大小，核心线程池大小，活动线程小于corePoolSize则直接创建，大于等于则先加到workQueue中，      * 队列满了才创建新的线程。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，      * 等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，      * 线程池会提前创建并启动所有基本线程。      * <span class="hljs-doctag">@param</span> maximumPoolSize 最大线程数，超过就reject；线程池允许创建的最大线程数。如果队列满了，      * 并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务      * <span class="hljs-doctag">@param</span> keepAliveTime      * 线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率      * <span class="hljs-doctag">@param</span> unit  线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、      * 毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）      * <span class="hljs-doctag">@param</span> workQueue 工作队列，线程池中的工作线程都是从这个工作队列源源不断的获取任务进行执行      */</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,                <span class="hljs-keyword">int</span> maximumPoolSize,                <span class="hljs-keyword">long</span> keepAliveTime,                TimeUnit unit,                BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>{         <span class="hljs-comment">// threadFactory用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</span>         <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,                 Executors.defaultThreadFactory(), defaultHandler);     }<span class="copy-code-btn">复制代码</span></code></code></pre> <h3>向线程池提交任务</h3> <p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p> <pre><code class="language-java"><code class="hljs java copyable">threadsPool.execute(<span class="hljs-keyword">new</span> Runnable() {         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{         }     });<span class="copy-code-btn">复制代码</span></code></code></pre> <p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p> <pre><code class="language-javascript"><code class="hljs javascript copyable">Future&lt;<span class="hljs-built_in">Object</span>&gt; future = executor.submit(harReturnValuetask);   <span class="hljs-keyword">try</span>     {         <span class="hljs-built_in">Object</span> s = future.get();     }<span class="hljs-keyword">catch</span>(     InterruptedException e)     {         <span class="hljs-comment">// 处理中断异常</span>     }<span class="hljs-keyword">catch</span>(     ExecutionException e)     {         <span class="hljs-comment">// 处理无法执行任务异常</span>     }<span class="hljs-keyword">finally</span>     {         <span class="hljs-comment">// 关闭线程池</span>         executor.shutdown();     }<span class="copy-code-btn">复制代码</span></code></code></pre> <h3>关闭线程池</h3> <p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p> <p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p> <h3>合理的配置线程池</h3> <p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p> <p>1、任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</p> <p>2、任务的优先级：高、中和低。</p> <p>3、任务的执行时间：长、中和短。</p> <p>4、任务的依赖性：是否依赖其他系统资源，如数据库连接。</p> <p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行</p> <p>如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p> <p>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有时候我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p> <h3>线程池的监控</h3> <p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性</p> <ul> <li>taskCount：线程池需要执行的任务数量。</li> <li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li> <li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li> <li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li> <li>getActiveCount：获取活动的线程数。</li> </ul> <p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等</p> <p></p> </div></div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-66020.htm">元旦送什么礼物给女朋友好呢(10-15岁女孩礼物推荐)</a></p>
                                        <p>下一个：<a href="/news/article-66659.htm">动物疫苗可以快递吗现在能打吗（动物疫苗可以快递吗现在能打吗有毒吗）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2025-3-1-clash-node-daily-updates.htm" title="「3月1日」最高速度20.1M/S，2025年Clash/V2ray/Shadowrocket/SSR每天更新免费节点订阅链接">「3月1日」最高速度20.1M/S，2025年Clash/V2ray/Shadowrocket/SSR每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-67308.htm" title="宠物粮食品牌前十排名榜图片大全集（宠物粮食品牌前十排名榜图片大全集最新）">宠物粮食品牌前十排名榜图片大全集（宠物粮食品牌前十排名榜图片大全集最新）</a></li>
                        <li class="py-2"><a href="/news/article-61778.htm" title="宠物店猫粮多少钱一袋合适（宠物店里的猫粮一般多少钱）">宠物店猫粮多少钱一袋合适（宠物店里的猫粮一般多少钱）</a></li>
                        <li class="py-2"><a href="/news/article-55497.htm" title="深圳宠物领养小程序（深圳领养宠物狗）">深圳宠物领养小程序（深圳领养宠物狗）</a></li>
                        <li class="py-2"><a href="/news/article-58513.htm" title="宠颐生动物医院官网 宠颐生动物医院简介">宠颐生动物医院官网 宠颐生动物医院简介</a></li>
                        <li class="py-2"><a href="/news/article-53847.htm" title="编码练习：JavaScript 点击下拉列表显示相关信息">编码练习：JavaScript 点击下拉列表显示相关信息</a></li>
                        <li class="py-2"><a href="/news/article-36742.htm" title="宠物食品加工厂要投资多少亿 宠物食品加工厂要投资多少亿元">宠物食品加工厂要投资多少亿 宠物食品加工厂要投资多少亿元</a></li>
                        <li class="py-2"><a href="/news/article-38196.htm" title="宠物领养怎么赚钱快（宠物领养怎么赚钱快点）">宠物领养怎么赚钱快（宠物领养怎么赚钱快点）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-24-clash-node-daily-updates.htm" title="「2月24日」最高速度18.5M/S，2025年Shadowrocket/SSR/V2ray/Clash每天更新免费节点订阅链接">「2月24日」最高速度18.5M/S，2025年Shadowrocket/SSR/V2ray/Clash每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-29-free-shadowrocket-node.htm" title="「1月29日」最高速度22.2M/S，2025年Clash/Shadowrocket/V2ray/SSR每天更新免费节点订阅链接">「1月29日」最高速度22.2M/S，2025年Clash/Shadowrocket/V2ray/SSR每天更新免费节点订阅链接</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">15</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">84</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div> <!-- .container -->
    </div> <!-- .page-section -->
        <footer class="page-footer bg-image" style="background-image: url(/assets/website/img/clashstash/world_pattern.svg);">
        <div class="container">
            <p class="text-center" id="copyright">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                <a href="/">ClashStash官方节点站</a> 版权所有
                <br />Powered by WordPress
            </p>
        </div>
    </footer>
    <script src="/assets/website/js/frontend/clashstash/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/clashstash/bootstrap.bundle.min.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>